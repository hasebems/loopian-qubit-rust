ダブルバッファリングの目的と効果

このコードでは、OLED表示の更新と描画処理を並列化するためにダブルバッファリングが使われています。

[初期状態]
BUFFER_FROM_DISPLAY に2つの空バッファを投入
          ↓
┌─────────────────────────────────────┐
│ BUFFER_FROM_DISPLAY (空バッファ待ち) │
└─────────────────┬───────────────────┘
                  ↓
    【Core1: UI Task (高速)】
    - 空バッファを受信 (450行目)
    - 描画処理を実行 (454行目)
                  ↓
┌─────────────────────────────────────┐
│ BUFFER_TO_DISPLAY (描画済みバッファ)  │
└─────────────────┬───────────────────┘
                  ↓
    【Core1: I2C Task (低速)】
    - 描画済みバッファを受信 (406行目)
    - OLEDに転送 (409行目) ← I2C通信で遅い
    - バッファを返却 (414行目)
                  ↓
         (循環して最初に戻る)

## 期待される効果

* 並列処理による高速化
    - UI Taskが描画している間、I2C TaskはOLEDに転送できる
    - バッファが2つあるので、片方を描画中にもう片方を転送可能
* I2C通信の待ち時間を隠蔽
    - OLED表示の更新（I2C通信）は比較的遅い
    - 転送中に次のフレームの描画を進められる
* フレームレートの向上
    - 単一バッファだと：描画→転送→描画→転送（直列処理）
    - 2バッファだと：描画と転送を並行実行可能
* デッドロック回避
    - 容量2のチャンネルで循環させ、両タスクが相互に待ち状態にならないよう設計

これは、グラフィックス処理でよく使われるフリップバッファリングの手法で、描画と表示を並列化してパフォーマンスを最大化しています。

